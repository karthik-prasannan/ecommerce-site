# same method name with same number of arguments
# it is used to change the behaviour of existing method,and there is a need for atleast 2 classes for method overriding
# in method overriding ,inheritance always required as it is done between parant class (superclass)and childclass(base class)
# method

# abc.text : my new file

# class A:
#     def display(self):
#         print('method A')
#     def display1(self):
#         print('method B')
# obj=A()
# obj.display()
# obj.display1()

# class father:
#     def phone(self):
#         print("father's phone")
# class child(father):
#     def phone(self):
#         print("child's phone")
# obj=child()
# obj.phone()

# over riding with multiple inheritance

# class A:
#     def fun(self):
#         print('class A')
# class B:
#     def fun1(self):
#         print('class B')
# class C(A,B):
#     def fun(self):
#         print('class A changes to class C')
#     def fun1(self):
#         print('class B changes to class C')

# obj=C()
# obj.fun()
# obj.fun1()

# class c that overrides class A and class B

# overriding using multilevel inheritance

# class A:
#     def fun(self):
#         print('class A')
# class B(A):
#     def fun(self):
#         print('class B')
# class C(B):
#     def fun(self):
#         print('class C')
#
#
# obj=C()
# obj.fun()













